C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 22:17:35 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\keil_C51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\mai
                    -n.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Timer0.h"
   3          #include "Key.h"
   4          #include "Nixie.h"
   5          #include "Delay.h"
   6          #include "AT24C02.h"
   7          
   8          unsigned char KeyNum;
   9          unsigned char Min, Sec, MiniSec;
  10          unsigned char RunFlag;
  11          
  12          void main()
  13          {
  14   1          Timer0Init();
  15   1          while(1)
  16   1          {
  17   2              KeyNum = Key();
  18   2              if(KeyNum == 1)            //K1按键按下：启停切换
  19   2              {
  20   3                  RunFlag = !RunFlag;
  21   3              }
  22   2              if(KeyNum == 2)            //K2按键按下：清零
  23   2              {
  24   3                  Min = 0;
  25   3                  Sec = 0;
  26   3                  MiniSec = 0;
  27   3              }
  28   2              if(KeyNum == 3)            //K3按键按下：保存数据
  29   2              {
  30   3                  AT24C02_WriteByte(0, Min);
  31   3                  Delay1ms(5);
  32   3                  AT24C02_WriteByte(1, Sec);
  33   3                  Delay1ms(5);
  34   3                  AT24C02_WriteByte(2, MiniSec);
  35   3                  Delay1ms(5);
  36   3              }
  37   2              if(KeyNum == 4)            //K4按键按下：读取数据
  38   2              {
  39   3                  Min = AT24C02_ReadByte(0);
  40   3                  Sec = AT24C02_ReadByte(1);
  41   3                  MiniSec = AT24C02_ReadByte(2);
  42   3                  // 读取后增加范围修正，避免超出合理范围
  43   3                  Min %= 60;    // 分钟最大59
  44   3                  Sec %= 60;    // 秒钟最大59
  45   3                  MiniSec %= 100;// 毫秒位最大99
  46   3              }
  47   2              
  48   2              // 数码管显示：增加数值范围检查，避免段码索引越界
  49   2              Nixie_SetBuf(1, (Min/10) % 10);    // 分钟十位（0-5）
  50   2              Nixie_SetBuf(2, Min%10);           // 分钟个位（0-9）
  51   2              Nixie_SetBuf(3, 11);               // 分隔符（段码表11）
  52   2              Nixie_SetBuf(4, (Sec/10) % 10);    // 秒钟十位（0-5）
  53   2              Nixie_SetBuf(5, Sec%10);           // 秒钟个位（0-9）
  54   2              Nixie_SetBuf(6, 11);               // 分隔符
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 22:17:35 PAGE 2   

  55   2              Nixie_SetBuf(7, (MiniSec/10) % 10);// 毫秒十位（0-9）
  56   2              Nixie_SetBuf(8, MiniSec%10);       // 毫秒个位（0-9）
  57   2          }
  58   1      }
  59          
  60          /**
  61            * @brief  秒表驱动函数，在中断中调用
  62            * @param  无
  63            * @retval 无
  64            */
  65          void Sec_Loop(void)
  66          {
  67   1          if(RunFlag)
  68   1          {
  69   2              MiniSec++;
  70   2              if(MiniSec >= 100)    // 100个10ms = 1秒
  71   2              {
  72   3                  MiniSec = 0;
  73   3                  Sec++;
  74   3                  if(Sec >= 60)
  75   3                  {
  76   4                      Sec = 0;
  77   4                      Min++;
  78   4                      if(Min >= 60)    // 分钟最大59
  79   4                      {
  80   5                          Min = 0;
  81   5                      }
  82   4                  }
  83   3              }
  84   2          }
  85   1      }
  86          
  87          void Timer0_Routine() interrupt 1
  88          {
  89   1          static unsigned int T0Count1, T0Count2, T0Count3;
  90   1          TL0 = 0x18;        //设置定时初值（1ms@12MHz）
  91   1          TH0 = 0xFC;
  92   1          T0Count1++;
  93   1          if(T0Count1 >= 20)    // 20ms扫描一次按键
  94   1          {
  95   2              T0Count1 = 0;
  96   2              Key_Loop();
  97   2          }
  98   1          T0Count2++;
  99   1          if(T0Count2 >= 2)    // 2ms扫描一次数码管（刷新频率更高，显示更稳定）
 100   1          {
 101   2              T0Count2 = 0;
 102   2              Nixie_Loop();
 103   2          }
 104   1          T0Count3++;
 105   1          if(T0Count3 >= 10)    // 10ms更新一次秒表计数
 106   1          {
 107   2              T0Count3 = 0;
 108   2              Sec_Loop();
 109   2          }
 110   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    433    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 22:17:35 PAGE 3   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
